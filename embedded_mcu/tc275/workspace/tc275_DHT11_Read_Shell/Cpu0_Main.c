/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"
#include <stdio.h>
#include "IfxAsclin_Asc.h"
#include "IfxAsclin_PinMap.h"
#include "IfxCpu_Irq.h"

#define IFX_INTPRIO_ASCLIN3_TX 1
#define IFX_INTPRIO_ASCLIN3_RX 2
#define IFX_INTPRIO_ASCLIN3_ER 3

#define ASC_TX_BUFFER_SIZE 64
static uint8 ascTxBuffer[ASC_TX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];
#define ASC_RX_BUFFER_SIZE 64
static uint8 ascRxBuffer[ASC_RX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];

#define CCU60_BASE      0xF0002A00
#define CCU60_CLC       (*(volatile unsigned int*) (CCU60_BASE + 0x00))
#define CCU60_T12       (*(volatile unsigned int*) (CCU60_BASE + 0x20))
#define CCU60_T12PR     (*(volatile unsigned int*) (CCU60_BASE + 0x24))
#define CCU60_TCTR0     (*(volatile unsigned int*) (CCU60_BASE + 0x70))
#define CCU60_TCTR4     (*(volatile unsigned int*) (CCU60_BASE + 0x78))
#define CCU60_IEN       (*(volatile unsigned int*) (CCU60_BASE + 0xB0))
#define CCU60_INP       (*(volatile unsigned int*) (CCU60_BASE + 0xAC))
#define DISS            1
#define DISR            0
#define CTM             7
#define T12PRE          3
#define T12CLK          0
#define T12STR          6
#define T12RS           1
#define INPT12          10
#define ENT12PM         7

#define SCU_BASE        0xF0036000
#define SCU_WDT_CPU0CON0 (*(volatile unsigned int*) (SCU_BASE + 0x0100))
#define LCK             1
#define ENDINIT         0

#define SRC_BASE        0xF0038000
#define SRC_CCU60_SR0    (*(volatile unsigned int*) (SRC_BASE + 0x0420))
#define TOS             11
#define SRE             10
#define SRPN            0


#define PIN_LED13       &MODULE_P10,2

#define PIN_DHT         &MODULE_P10,4

#define DHT11_RETRY_DELAY 1000  // 1000ms
#define LOW             0
#define HIGH            1


unsigned long millis(void);
unsigned long micros(void);
void delay(unsigned long time);
void delayMicroseconds(int time_us);

char DHT11_readByte(void);
void DHT11_waitFor(short target);
int DHT11_read( float* humidity, float* temperature );
unsigned long DHT11_waitFor_time(short target, unsigned long time_out_us);


IfxAsclin_Asc asclin_console;

void init_CCU60 (void);

volatile unsigned long millis_val = 0;
volatile unsigned long micros_val = 0;

unsigned long millis() {
    return millis_val;
}

unsigned long micros() {
    return micros_val;
}

void delay(unsigned long time_ms) {
    unsigned long startTime = millis();
    while ( millis() - startTime < time_ms );
}

void delayMicroseconds(int time_us) {
    unsigned long startTime = micros();
    while ( micros() - startTime < time_us );
}


__interrupt(0x0A) __vector_table(0)
void CCU60_T12_ISR (void) {
    micros_val++;
    if (micros_val % 1000 == 0) {
        millis_val++;
    }
}

IFX_INTERRUPT(asclin3TxISR, 0, IFX_INTPRIO_ASCLIN3_TX) {
    IfxAsclin_Asc_isrTransmit(&asclin_console);
}
IFX_INTERRUPT(asclin3RxISR, 0, IFX_INTPRIO_ASCLIN3_RX) {
    IfxAsclin_Asc_isrReceive(&asclin_console);
}
IFX_INTERRUPT(asclin3ErISR, 0, IFX_INTPRIO_ASCLIN3_ER) {
    IfxAsclin_Asc_isrError(&asclin_console);
}

void ASC3_init() {
    // create module config
    IfxAsclin_Asc_Config ascConfig;

    IfxAsclin_Asc_initModuleConfig(&ascConfig, &MODULE_ASCLIN3);

    // set the desired baudrate
    ascConfig.baudrate.prescaler = 1;
    ascConfig.baudrate.baudrate = 9600;
    ascConfig.baudrate.oversampling = IfxAsclin_OversamplingFactor_4;

    // ISR priorities and interrupt target
    ascConfig.interrupt.txPriority = IFX_INTPRIO_ASCLIN3_TX;
    ascConfig.interrupt.rxPriority = IFX_INTPRIO_ASCLIN3_RX;
    ascConfig.interrupt.erPriority = IFX_INTPRIO_ASCLIN3_ER;
    ascConfig.interrupt.typeOfService = IfxSrc_Tos_cpu0;

    // FIFO configuration
    ascConfig.txBuffer     = &ascTxBuffer;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
    ascConfig.rxBuffer     = &ascRxBuffer;
    ascConfig.rxBufferSize = ASC_RX_BUFFER_SIZE;
    // pin configuration
    const IfxAsclin_Asc_Pins pins
        = {NULL,
           IfxPort_InputMode_pullUp,        // CTS pin not used
           &IfxAsclin3_RXD_P32_2_IN,        // USB IN
           IfxPort_InputMode_pullUp,        // Rx pin
           NULL,
           IfxPort_OutputMode_pushPull,     // RTS pin not used
           &IfxAsclin3_TX_P15_7_OUT,        // USB OUT
           IfxPort_OutputMode_pushPull,     // Tx pin
           IfxPort_PadDriver_cmosAutomotiveSpeed1};
    ascConfig.pins = &pins;
    IfxAsclin_Asc_initModule(&asclin_console, &ascConfig);
}

void printDHT(float t, float h) {
    char text[30] = "t:     C h:     %\n\r";

    text[2] = (t / 10) + '0';
    text[3] = ((int)t % 10) + '0';
    text[4] = '.';
    text[5] = ((int)(t*10) % 10) + '0';
    text[6] = ((int)(t*100) % 10) + '0';

    text[11] = (h / 10) + '0';
    text[12] = ((int)h % 10) + '0';
    text[13] = '.';
    text[14] = ((int)(h*10) % 10) + '0';
    text[15] = ((int)(h*100) % 10) + '0';

    Ifx_SizeT len = 21;
    IfxAsclin_Asc_write(&asclin_console, text, &len, TIME_INFINITE);
}


unsigned long last_read_time = 0;


int err = 0;
float temp, humi = 0.00;

IfxCpu_syncEvent g_cpuSyncEvent = 0;

int core0_main(void)
{
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);

    init_CCU60();
    ASC3_init();

    IfxPort_setPinModeInput(PIN_DHT, IfxPort_InputMode_pullUp);


    IfxPort_setPinModeOutput(PIN_LED13, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
        
    while(1)
    {
        IfxPort_setPinHigh(PIN_LED13);
        err = DHT11_read(&humi, &temp);

        if(err == 0) {
            //printf("t:%.2f h:%.2f \n", temp, humi);     //code stops because of "printf" BUG!!!
            printDHT(temp, humi);
        } else {
            //printf("E: %d \n", err);     //code stops because of "printf" BUG!!!
            char text[30] = "Err: \n\r";
            text[4] = err + '0';
            Ifx_SizeT len = 9;
            IfxAsclin_Asc_write(&asclin_console, text, &len, TIME_INFINITE);
        }
        delay(500);
        IfxPort_setPinLow(PIN_LED13);
        delay(1500);
    }
    return (1);
}


int DHT11_read( float* humidity, float* temperature ) {
    if( ( millis() - last_read_time < DHT11_RETRY_DELAY ) && last_read_time != 0 )
      return -1;

    IfxPort_setPinModeOutput(PIN_DHT, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinLow(PIN_DHT);
    delay(18);
    IfxPort_setPinHigh(PIN_DHT);
    IfxPort_setPinModeInput(PIN_DHT, IfxPort_InputMode_pullUp);

    if(DHT11_waitFor_time(LOW, 40)<0)  return 1; //waiting for DH11 ready
    if(DHT11_waitFor_time(HIGH, 90)<0) return 1; //waiting for first LOW signal(80us)
    if(DHT11_waitFor_time(LOW, 90)<0)  return 1; //waiting for first HIGH signal(80us)

    char hI = DHT11_readByte();
    char hF = DHT11_readByte();
    char tI = DHT11_readByte();
    char tF = DHT11_readByte();
    char cksum = DHT11_readByte();


    if (hI+hF+tI+tF != cksum)
        return 4;

    *humidity = (float)hI + ( ((float)hF)/100.0F );
    *temperature = (float)tI + ( ((float)tF)/100.0F );
    last_read_time = millis();
    return 0;
}

void DHT11_waitFor(short target) {
    while( IfxPort_getPinState(PIN_DHT) != target );
}

unsigned long DHT11_waitFor_time(short target, unsigned long time_out_us) {
    unsigned long start = micros();
    unsigned long time_out = start + time_out_us;
    while( IfxPort_getPinState(PIN_DHT) != target ) {
        if(time_out < micros())
            return -1;
    }
    return micros() - start;
}

//read one bye
char DHT11_readByte() {
    int i = 0;
    char ret = 0;
    for (i = 7; i >= 0; i--) {
        DHT11_waitFor_time(HIGH, 50); //wait for 50us in LOW status
        delayMicroseconds(65); //wait for 30us
        if( IfxPort_getPinState(PIN_DHT) == HIGH ) //if HIGH status lasts for 30us, the bit is 1;
        {
            ret |= 1 << (i);
            DHT11_waitFor_time(LOW, 90); //wait for rest time in HIGH status.
        }
    }
    return ret;
}

void init_CCU60 (void) {
    SCU_WDT_CPU0CON0 = ((SCU_WDT_CPU0CON0 ^ 0xFC) & ~(1<<LCK)) |  (1<<ENDINIT);
    while((SCU_WDT_CPU0CON0 & (1<<LCK)) != 0);

    SCU_WDT_CPU0CON0 = ((SCU_WDT_CPU0CON0 ^ 0xFC) |  (1<<LCK)) & ~(1<<ENDINIT);
    while((SCU_WDT_CPU0CON0 & (1<<LCK)) == 0);

    CCU60_CLC &= ~(1<<DISR);

    SCU_WDT_CPU0CON0 = ((SCU_WDT_CPU0CON0 ^ 0xFC) & ~(1<<LCK)) |  (1<<ENDINIT);
    while((SCU_WDT_CPU0CON0 & (1<<LCK)) != 0);

    SCU_WDT_CPU0CON0 = ((SCU_WDT_CPU0CON0 ^ 0xFC) |  (1<<LCK)) |  (1<<ENDINIT);
    while((SCU_WDT_CPU0CON0 & (1<<LCK)) == 0);

    while((CCU60_CLC & (1<<DISS)) != 0);

    CCU60_TCTR0 &= ~((0x07) << T12CLK);
    CCU60_TCTR0 |=  ((0x01) << T12CLK);

    CCU60_TCTR0 &= ~((0x01) << CTM);

    CCU60_T12PR = 49;    //period 1us
    CCU60_TCTR4 |=  ((0x01)<<T12STR);

    CCU60_T12 = 0;

    CCU60_INP &= ~((0x03)<<INPT12);

    CCU60_IEN |=  ((0x01)<<ENT12PM);

    SRC_CCU60_SR0 &= ~((0xFF)<<SRPN);
    SRC_CCU60_SR0 |=  ((0x0A)<<SRPN);

    SRC_CCU60_SR0 &= ~((0x03)<<TOS);

    SRC_CCU60_SR0 |=  ((0x01)<<SRE);

    CCU60_TCTR4 = ((0x01)<<T12RS);

}
